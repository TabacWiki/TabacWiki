<!DOCTYPE html>
<!-- Version 1.0.1 -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tabac Wiki</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #121212;
            color: #e0e0e0;
        }
        .title-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px;
            margin-bottom: 2rem;
        }
        .site-logo {
            width: 48px;
            height: 48px;
            transition: transform 0.3s ease, filter 0.3s ease;
        }
        .site-logo:hover {
            transform: scale(1.2) rotate(5deg) skew(5deg);
            filter: brightness(1.2);
        }
        #suggestionsList {
            max-height: 300px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #352c26 #241e1c;
        }
        #suggestionsList::-webkit-scrollbar {
            width: 8px;
        }
        
        #suggestionsList::-webkit-scrollbar-track {
            background: #241e1c;
        }
        
        #suggestionsList::-webkit-scrollbar-thumb {
            background-color: #352c26;
            border-radius: 4px;
            border: 2px solid #241e1c;
        }

        #suggestionsList .suggestion-item:hover {
            background-color: rgba(255,255,255,0.1);
        }
        #debugOutput {
            background-color: rgba(74, 43, 43, 0);
            color: rgba(36, 36, 36, 0);
            padding: 10px;
            margin-top: 20px;
            white-space: pre-wrap;
            word-break: break-all;
        }

        /* Custom Scrollbar */
        .custom-scrollbar {
            scrollbar-width: thin;
            scrollbar-color: #352c26 #241e1c;
        }
        
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #241e1c;
        }
        
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background-color: #352c26;
            border-radius: 4px;
            border: 2px solid #241e1c;
        }
        .custom-checkbox-container {
            display: flex;
            align-items: center;
            padding: 6px 8px;
            border-radius: 6px;
            transition: background-color 0.2s;
            cursor: pointer;
            gap: 20px;
        }
        .custom-checkbox-container:hover {
            background-color: rgba(255,255,255,0.05);
        }
        .custom-checkbox {
            position: relative;
            width: 18px;
            height: 18px;
            border: 2px solid #4b3f38b5;
            border-radius: 4px;
            transition: all 0.2s;
            cursor: pointer;

        }
        .custom-checkbox input[type='checkbox'] {
            opacity: 0;
            position: absolute;
            width: 100%;
            height: 100%;
            cursor: pointer;
            z-index: 2;
        }
        .custom-checkbox .checkmark {
            position: absolute;
            top: 1px;
            left: 1px;
            width: 12px;
            height: 12px;
            background-color: #1f1a18;
            border-radius: 2px;
            transform: scale(0);
            transition: transform 0.2s;
        }
        .custom-checkbox input[type='checkbox']:checked + .checkmark {
            transform: scale(1);
        }
        .custom-checkbox input[type='checkbox']:checked ~ .custom-checkbox {
            border-color: #322222;
        }
        .custom-checkbox-label {
            font-size: 0.9rem;
            color: #E5E7EB;
            user-select: none;

        }
        .upload-container {
            position: relative;
            cursor: pointer;
        }
        .upload-hover-banner {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(200, 159, 101, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s ease;
            color: #27201E;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-radius: 0.5rem;
        }
        .upload-container:hover .upload-hover-banner {
            opacity: 1;
        }
        @keyframes flag-wave {
            0%, 100% { transform: rotate(0deg) skew(0deg); }
            50% { transform: rotate(10deg) skew(5deg); }
        }
        .flag-wave {
            animation: flag-wave 1.5s ease-in-out infinite;
        }
        html, body {
            height: 100vh;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        .responsive-layout {
            display: flex;
            flex-direction: column;
            height: 100vh;
            max-height: 100vh;
        }
        .main-content {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
        }
        .sidebar {
            width: 16rem;
            overflow-y: auto;
        }
        .content-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .results-container {
            flex-grow: 1;
            overflow-y: auto;
        }
        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            .sidebar {
                width: 100%;
                max-height: none;
            }
            /* Ensure the content area scrolls properly on mobile */
            .content-area {
                flex: 1;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }
        }
        
        /* Responsive Base Styles */
        html, body {
            height: 100vh;
            margin: 0;
            padding: 0;
            font-size: 16px;
        }
        
        /* Full Viewport Layout */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        
        /* Main Content Area */
        .main-content {
            display: flex;
            flex-grow: 1;
        }
        
        /* Sidebar */
        .sidebar {
            width: 16rem;
            background-color: #241e1c;
            border-right: 1px solid #27201e;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            flex-shrink: 0;
        }
        
        /* Content Area */
        .content-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        /* Scrollable Results */
        .results-container {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1rem;
        }
        
        /* Responsive Breakpoints */
        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                max-height: 50vh;
            }
            
            html, body {
                font-size: 14px;
            }
        }
        
        /* Utility Classes */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        
        /* Blend Card Styles */
        .blend-card {
            position: relative;
            transition: all 0.3s ease;
        }
        .blend-card .hover-details {
            position: absolute;
            inset: 0;
            background-color: #241e1c;
            color: #8E8074;
            padding: 0.75rem;
            border-radius: 0.5rem;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        .blend-card:hover .hover-details {
            opacity: 1;
        }
        .hover-details .detail-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.875rem; /* text-sm */
            color: #8E8074;
            margin-bottom: 0.5rem;
        }
        .hover-details .detail-row:first-child span:first-child,
        .hover-details .detail-row:nth-child(2) span:first-child {
            color: inherit;
            font-style: normal;
        }
        .hover-details .detail-row:last-child {
            text-align: center;
            justify-content: center;
        }
    </style>
</head>
<body class="bg-[#1f1a18] text-[#8E8074] custom-scrollbar">
    <div class="app-container">
        <div id="initialLoadingOverlay" class="fixed inset-0 bg-[#1f1a18]/80 z-[1000] flex flex-col items-center justify-center">
            <img src="/favicon.ico" alt="Tabac Wiki Logo" class="w-24 h-24 flag-wave">
            <p class="text-[#8E8074] text-lg mt-4 tracking-wider">Loading database...</p>
        </div>

        <div class="main-content flex flex-col md:flex-row flex-1 overflow-hidden custom-scrollbar" id="searchContainer">
            <!-- Sidebar -->
            <!-- Mobile Header with Logo, Search, and Filters -->
            <div id="mobileHeader" class="md:hidden flex flex-col bg-[#241e1c] sticky top-0 z-10 transition-all duration-300 ease-in-out shadow-lg shadow-black/25">
                <div class="flex flex-col p-4 gap-4">
                    <div class="flex items-center justify-between relative">
                        <button id="mobileInfoButton" class="w-auto p-2 hover:bg-[#352c26]/40 rounded-lg transition-colors duration-200 text-[#8E8074] flex items-center justify-center">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                        </button>
                        <div class="absolute left-1/2 -translate-x-1/2 flex items-center gap-2">
                            <img src="/favicon.ico" alt="Tabac Wiki Leaf" class="w-8 h-8">
                            <a href="https://tabac.wiki" class="hover:transform hover:scale-110 hover:brightness-110 transition-all duration-300 ease-in-out">
                                <img src="/assets/logo.png" alt="Tabac Wiki" class="h-6 w-auto max-w-full object-contain object-left">
                            </a>
                        </div>
                        <div class="invisible flex items-center gap-2">
                            <img src="/favicon.ico" alt="" class="w-8 h-8">
                            <div class="h-6 w-[100px]"></div>
                        </div>
                        <button id="mobileFilterToggle" class="w-auto p-2 hover:bg-[#352c26]/40 rounded-lg transition-colors duration-200 text-[#8E8074] flex items-center gap-2">
                            <svg class="w-6 h-6 pointer-events-none" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="z-index: -1;">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4"></path>
                            </svg>
                            <span class="pointer-events-none">Filters</span>
                        </button>
                    </div>
                    <div class="flex gap-2 w-full">
                        <button id="mobileDonationButton" class="flex-1 bg-[#352c26]/40 hover:bg-[#352c26]/60 text-[#8E8074] text-sm font-medium px-4 py-2.5 rounded-lg focus:outline-none focus:ring-2 focus:ring-[#7D6A55] transition-all duration-200 whitespace-nowrap">Support The Wiki</button>
                        <button id="mobileStatusButton" class="flex-1 bg-[#352c26]/40 hover:bg-[#352c26]/60 text-[#8E8074] text-sm font-medium px-4 py-2.5 rounded-lg focus:outline-none focus:ring-2 focus:ring-[#7D6A55] transition-all duration-200 whitespace-nowrap">Wiki Report</button>
                    </div>
                </div>
                <!-- Mobile Search Bar -->
                <div class="px-4 pb-4 md:hidden">
                    <input type="text" id="searchInput" placeholder="Search blends..." class="w-full px-3 py-2 bg-[#352c26]/40 text-[#8E8074] placeholder:text-[#8E8074]/50 rounded-lg focus:outline-none focus:ring-2 focus:ring-[#7D6A55] hover:ring-1 hover:ring-[#7D6A55] transition-all duration-200">
                </div>
            </div>



            <!-- Collapsible Sidebar -->
            <div id="mobileSidebar" class="sidebar hidden md:block w-full md:w-64 bg-[#241e1c] md:flex-shrink-0 overflow-y-auto transition-all duration-300 ease-in-out custom-scrollbar md:!w-64 md:shadow-lg md:shadow-black/25 relative">
                <div class="px-4 py-8">
                    <div class="title-container hidden md:flex items-center mb-4">
                        <img src="/favicon.ico" alt="Tabac Wiki Leaf" class="site-logo mr-2 w-10 h-10">
                        <a href="https://tabac.wiki" class="site-title-link hover:transform hover:scale-110 hover:brightness-110 transition-all duration-300 ease-in-out">
                            <img src="/assets/logo.png" alt="Tabac Wiki" class="h-8 w-auto max-w-full object-contain object-left">
                        </a>
                    </div>

                    <!-- Desktop donation buttons -->
                    <div class="hidden md:flex justify-center items-stretch gap-1 w-full max-w-[200px] mx-auto mb-8">
                        <button id="donationButton" class="flex-1 bg-[#352c26]/40 hover:bg-[#352c26]/60 text-[#8E8074] text-xs font-medium px-1.5 py-2 rounded-lg focus:outline-none focus:ring-2 focus:ring-[#7D6A55] transition-all duration-200 whitespace-nowrap flex items-center justify-center">Support The Wiki</button>
                        <button id="statusButton" class="flex-1 bg-[#352c26]/40 hover:bg-[#352c26]/60 text-[#8E8074] text-xs font-medium px-1.5 py-2 rounded-lg focus:outline-none focus:ring-2 focus:ring-[#7D6A55] transition-all duration-200 whitespace-nowrap flex items-center justify-center">Wiki Report</button>
                        <button id="infoButton" class="h-[32px] w-[32px] bg-[#352c26]/40 hover:bg-[#352c26]/60 text-[#8E8074] text-xs font-medium rounded-lg focus:outline-none focus:ring-2 focus:ring-[#7D6A55] transition-all duration-200 flex items-center justify-center flex-shrink-0">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                        </button>
                    </div>

                    <!-- Desktop Search Bar -->
                    <div class="hidden md:block mb-8">
                        <div class="relative">
                            <input type="text" id="desktopSearchInput" placeholder="Search blends..." class="w-full px-3 py-2 bg-[#352c26]/40 text-[#8E8074] placeholder:text-[#8E8074]/50 rounded-lg focus:outline-none focus:ring-2 focus:ring-[#7D6A55] hover:ring-1 hover:ring-[#7D6A55] transition-all duration-200">
                        </div>
                    </div>
                    <div class="flex items-center justify-between mb-4">
                        <h3 class="text-xl font-semibold text-[#8E8074]">Sort By</h3>
                        <button id="resetFiltersBtn" class="text-sm text-[#8E8074] hover:text-[#C89F65] transition-colors duration-300 bg-[#352c26]/40 px-2 py-1 rounded-md">
                            Reset
                        </button>
                    </div>
                    <select id="sortDropdown" class="w-full px-3 py-2 bg-[#352c26]/40 text-[#8E8074] rounded-lg focus:outline-none focus:ring-2 focus:ring-[#7D6A55]">
                        <option value="" disabled selected>Select Sort Option</option>
                        <option value="averageRating">Rating Score (High to Low)</option>
                        <option value="ratingLowToHigh">Rating Score (Low to High)</option>
                        <option value="reviewCount">Rating Count (High to Low)</option>
                        <option value="reviewCountLowToHigh">Rating Count (Low to High)</option>
                        <option value="blenderAsc">Brand (A to Z)</option>
                        <option value="blenderDesc">Brand (Z to A)</option>
                        <option value="alphaAsc">Blend (A to Z)</option>
                        <option value="alphaDesc">Blend (Z to A)</option>
                    </select>
                    
                    <!-- Collapsible filters section for desktop -->
                    <div class="hidden md:flex items-center justify-between cursor-pointer mt-8 mb-4" id="filtersHeader">
                        <h3 class="text-xl font-semibold text-[#8E8074]">Filters</h3>
                        <svg id="filtersArrow" class="w-5 h-5 text-[#8E8074] transform transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                        </svg>
                    </div>
                    <!-- Mobile-only filters header -->
                    <h3 class="text-xl font-semibold mt-8 mb-4 text-[#8E8074] md:hidden">Filters</h3>
                    <!-- Two-column grid for filter dropdowns -->
                    <div id="filtersContainer" class="md:block grid grid-cols-2 gap-4 md:space-y-4">
                        <select id="blenderDropdown" class="w-full px-3 py-2 bg-[#352c26]/40 text-[#8E8074] rounded-lg focus:outline-none focus:ring-2 focus:ring-[#7D6A55]">
                            <option value="" selected>All Brands</option>
                        </select>

                        <select id="blendedByDropdown" class="w-full px-3 py-2 bg-[#352c26]/40 text-[#8E8074] rounded-lg focus:outline-none focus:ring-2 focus:ring-[#7D6A55]">
                            <option value="" selected>All Blenders</option>
                        </select>

                        <select id="manufacturedByDropdown" class="w-full px-3 py-2 bg-[#352c26]/40 text-[#8E8074] rounded-lg focus:outline-none focus:ring-2 focus:ring-[#7D6A55]">
                            <option value="" selected>All Manufacturers</option>
                        </select>

                        <select id="countryDropdown" class="w-full px-3 py-2 bg-[#352c26]/40 text-[#8E8074] rounded-lg focus:outline-none focus:ring-2 focus:ring-[#7D6A55]">
                            <option value="" selected>All Countries</option>
                        </select>

                        <select id="cutTypeDropdown" class="w-full px-3 py-2 bg-[#352c26]/40 text-[#8E8074] rounded-lg focus:outline-none focus:ring-2 focus:ring-[#7D6A55]">
                            <option value="" selected>All Cut Types</option>
                        </select>

                        <select id="packagingDropdown" class="w-full px-3 py-2 bg-[#352c26]/40 text-[#8E8074] rounded-lg focus:outline-none focus:ring-2 focus:ring-[#7D6A55]">
                            <option value="" selected>All Packaging Types</option>
                        </select>

                        <select id="blendTypeDropdown" class="w-full px-3 py-2 bg-[#352c26]/40 text-[#8E8074] rounded-lg focus:outline-none focus:ring-2 focus:ring-[#7D6A55]">
                            <option value="" selected>All Blend Types</option>
                        </select>

                        <select id="productionDropdown" class="w-full px-3 py-2 bg-[#352c26]/40 text-[#8E8074] rounded-lg focus:outline-none focus:ring-2 focus:ring-[#7D6A55]">
                            <option value="All availabilities" selected>All Availabilities</option>
                        </select>
                    </div>

                    <div class="my-4"></div>

                    <!-- Components section header for desktop -->
                    <div class="hidden md:flex items-center justify-between cursor-pointer mt-8 mb-4" id="componentsHeader">
                        <h3 class="text-xl font-semibold text-[#8E8074]">Components</h3>
                        <svg id="componentsArrow" class="w-5 h-5 text-[#8E8074] transform transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                        </svg>
                    </div>
                    <!-- Components section for mobile -->
                    <div class="md:hidden w-full px-3 py-2 bg-[#352c26]/40 text-[#8E8074] rounded-lg focus:outline-none focus:ring-2 focus:ring-[#7D6A55] hover:ring-1 hover:ring-[#7D6A55] transition-all duration-200">
                        <div class="flex items-center justify-between cursor-pointer" id="mobileComponentsHeader">
                            <h3 class="text-[#8E8074]">Components</h3>
                            <svg id="mobileComponentsArrow" class="w-5 h-5 text-[#8E8074] transform transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                            </svg>
                        </div>
                    </div>
                    <!-- Components checkbox container (shared between mobile and desktop) -->
                    <div id="componentsCheckboxContainer" class="space-y-2 hidden md:bg-[#352c26]/40 md:rounded-lg md:p-4 mt-2 md:mt-0"></div>

                    <div class="my-8"></div>

                    <div class="rating-filter-container px-4">
                        <label class="text-[#8E8074] text-sm mb-2 block text-center">Average Rating</label>
                        <div class="relative w-full py-2 flex justify-center">
                            <div id="ratingSlider" class="h-1.5 bg-[#27201E] rounded-full relative w-[250px]">
                                <div id="ratingTrack" class="absolute h-full bg-[#C89F65] rounded-full"></div>
                                <div 
                                    id="ratingMinHandle" 
                                    class="absolute w-4 h-4 bg-[#C89F65] rounded-full border-2 border-[#27201E] cursor-pointer -top-1.5"w-full px-3 py-2 bg-[#352c26]/40 text-[#8E8074] rounded-lg focus:outline-none focus:ring-2 focus:ring-[#7D6A55] hover:ring-1 hover:ring-[#7D6A55] transition-all duration-200

                                ></div>
                                <div 
                                    id="ratingMaxHandle" 
                                    class="absolute w-4 h-4 bg-[#C89F65] rounded-full border-2 border-[#27201E] cursor-pointer -top-1.5"
                                ></div>
                            </div>
                        </div>
                        <div class="flex justify-between text-[#8E8074] text-xs mt-2 px-4">
                            <span id="ratingMinValue">0</span>
                            <span id="ratingMaxValue">4</span>
                        </div>
                        <input 
                            type="hidden" 
                            id="ratingMinInput" 
                            name="rating_min" 
                            value="0"
                        >
                        <input 
                            type="hidden" 
                            id="ratingMaxInput" 
                            name="rating_max" 
                            value="4"
                        >
                    </div>

                    <div class="my-4"></div>

                    <div class="review-count-filter-container px-4">
                        <label class="text-[#8E8074] text-sm mb-2 block text-center">Rating Count</label>
                        <div class="relative w-full py-2 flex justify-center">
                            <div id="reviewCountSlider" class="h-1.5 bg-[#27201E] rounded-full relative w-[250px]">
                                <div id="reviewCountTrack" class="absolute h-full bg-[#C89F65] rounded-full"></div>
                                <div 
                                    id="reviewCountMinHandle" 
                                    class="absolute w-4 h-4 bg-[#C89F65] rounded-full border-2 border-[#27201E] cursor-pointer -top-1.5"
                                ></div>
                                <div 
                                    id="reviewCountMaxHandle" 
                                    class="absolute w-4 h-4 bg-[#C89F65] rounded-full border-2 border-[#27201E] cursor-pointer -top-1.5"
                                ></div>
                            </div>
                        </div>
                        <div class="flex justify-between text-[#8E8074] text-xs mt-2 px-4">
                            <span id="reviewCountMinValue">0</span>
                            <span id="reviewCountMaxValue">0</span>
                        </div>
                        <input 
                            type="hidden" 
                            id="reviewCountMinInput" 
                            name="review_count_min" 
                            value="0"
                        >
                        <input 
                            type="hidden" 
                            id="reviewCountMaxInput" 
                            name="review_count_max" 
                            value="0"
                        >
                    </div>

                    <script>
                        function createRatingRangeSlider() {
                            const slider = document.getElementById('ratingSlider');
                            const track = document.getElementById('ratingTrack');
                            const minHandle = document.getElementById('ratingMinHandle');
                            const maxHandle = document.getElementById('ratingMaxHandle');
                            const minValueDisplay = document.getElementById('ratingMinValue');
                            const maxValueDisplay = document.getElementById('ratingMaxValue');
                            const minInput = document.getElementById('ratingMinInput');
                            const maxInput = document.getElementById('ratingMaxInput');

                            let isDraggingMin = false;
                            let isDraggingMax = false;
                            const min = 0;
                            const max = 4;

                            function updateSlider(minValue, maxValue) {
                                const sliderWidth = slider.offsetWidth;
                                const minPercent = (minValue / max) * 100;
                                const maxPercent = (maxValue / max) * 100;

                                minHandle.style.left = `${minPercent}%`;
                                maxHandle.style.left = `${maxPercent}%`;
                                track.style.left = `${minPercent}%`;
                                track.style.width = `${maxPercent - minPercent}%`;

                                minValueDisplay.textContent = minValue.toFixed(1);
                                maxValueDisplay.textContent = maxValue.toFixed(1);
                                minInput.value = minValue;
                                maxInput.value = maxValue;
                            }

                            function getValueFromPosition(clientX) {
                                const rect = slider.getBoundingClientRect();
                                const percent = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
                                return Math.round(percent * max * 10) / 10;
                            }

                            function handleMouseMove(e) {
                                if (isDraggingMin) {
                                    let newMinValue = getValueFromPosition(e.clientX);
                                    const currentMaxValue = parseFloat(maxInput.value);
                                    newMinValue = Math.min(newMinValue, currentMaxValue);
                                    updateSlider(newMinValue, currentMaxValue);
                                }
                                if (isDraggingMax) {
                                    let newMaxValue = getValueFromPosition(e.clientX);
                                    const currentMinValue = parseFloat(minInput.value);
                                    newMaxValue = Math.max(newMaxValue, currentMinValue);
                                    updateSlider(currentMinValue, newMaxValue);
                                }
                            }

                            function handleTouchMove(e) {
                                e.preventDefault(); // Prevent scrolling while dragging
                                const touch = e.touches[0];
                                handleMouseMove({ clientX: touch.clientX });
                            }

                            function handleMouseUp() {
                                if (isDraggingMin || isDraggingMax) {
                                    // Only trigger filter when mouse/touch is released
                                    if (window.applyFiltersToResults) {
                                        applyFiltersToResults();
                                    }
                                    
                                    // Trigger search input to refresh results
                                    const searchInput = document.getElementById('searchInput');
                                    if (searchInput) {
                                        searchInput.dispatchEvent(new Event('input'));
                                    }
                                }
                                isDraggingMin = false;
                                isDraggingMax = false;
                                document.removeEventListener('mousemove', handleMouseMove);
                                document.removeEventListener('mouseup', handleMouseUp);
                            }

                            function handleTouchEnd() {
                                handleMouseUp();
                                document.removeEventListener('touchmove', handleTouchMove);
                                document.removeEventListener('touchend', handleTouchEnd);
                            }

                            // Mouse events
                            minHandle.addEventListener('mousedown', (e) => {
                                e.preventDefault();
                                isDraggingMin = true;
                                document.addEventListener('mousemove', handleMouseMove);
                                document.addEventListener('mouseup', handleMouseUp);
                            });

                            maxHandle.addEventListener('mousedown', (e) => {
                                e.preventDefault();
                                isDraggingMax = true;
                                document.addEventListener('mousemove', handleMouseMove);
                                document.addEventListener('mouseup', handleMouseUp);
                            });

                            // Touch events
                            minHandle.addEventListener('touchstart', (e) => {
                                e.preventDefault();
                                isDraggingMin = true;
                                document.addEventListener('touchmove', handleTouchMove, { passive: false });
                                document.addEventListener('touchend', handleTouchEnd);
                            });

                            maxHandle.addEventListener('touchstart', (e) => {
                                e.preventDefault();
                                isDraggingMax = true;
                                document.addEventListener('touchmove', handleTouchMove, { passive: false });
                                document.addEventListener('touchend', handleTouchEnd);
                            });

                            // Initial setup
                            updateSlider(0, 4);

                            // Add reset method to window scope
                            window.resetRatingSlider = () => {
                                // Reset to full range (0 to 4)
                                updateSlider(0, 4);

                                // Trigger filter application
                                if (window.applyFiltersToResults) {
                                    applyFiltersToResults();
                                }
                                
                                // Trigger search input to refresh results
                                const searchInput = document.getElementById('searchInput');
                                if (searchInput) {
                                    searchInput.dispatchEvent(new Event('input'));
                                }
                            };
                        }

                        function createReviewCountRangeSlider() {
                            const slider = document.getElementById('reviewCountSlider');
                            const track = document.getElementById('reviewCountTrack');
                            const minHandle = document.getElementById('reviewCountMinHandle');
                            const maxHandle = document.getElementById('reviewCountMaxHandle');
                            const minValueDisplay = document.getElementById('reviewCountMinValue');
                            const maxValueDisplay = document.getElementById('reviewCountMaxValue');
                            const minInput = document.getElementById('reviewCountMinInput');
                            const maxInput = document.getElementById('reviewCountMaxInput');

                            // Dynamically calculate max review count with smarter scaling
                            const reviewCounts = allBlends.map(blend => blend.reviewCount || 0);
                            const maxReviewCount = Math.max(...reviewCounts);
                            
                            // Custom scaling function to make smaller values more distinguishable
                            function scaleValue(value, max) {
                                // Logarithmic scaling with a soft curve
                                return Math.round(Math.pow(value / max, 0.7) * max);
                            }

                            function unscaleValue(scaledValue, max) {
                                // Reverse of the scaling function
                                return Math.round(Math.pow(scaledValue / max, 1/0.7) * max);
                            }

                            const roundedMaxReviewCount = Math.ceil(maxReviewCount / 10) * 10; // Round up to nearest 10

                            let isDraggingMin = false;
                            let isDraggingMax = false;
                            const min = 0;
                            const max = roundedMaxReviewCount;

                            function updateSlider(minValue, maxValue) {
                                const sliderWidth = slider.offsetWidth;
                                
                                // Apply custom scaling
                                const scaledMinPercent = (scaleValue(minValue, max) / max) * 100;
                                const scaledMaxPercent = (scaleValue(maxValue, max) / max) * 100;

                                minHandle.style.left = `${scaledMinPercent}%`;
                                maxHandle.style.left = `${scaledMaxPercent}%`;
                                track.style.left = `${scaledMinPercent}%`;
                                track.style.width = `${scaledMaxPercent - scaledMinPercent}%`;

                                // Display actual values
                                minValueDisplay.textContent = Math.round(minValue);
                                maxValueDisplay.textContent = Math.round(maxValue);
                                minInput.value = Math.round(minValue);
                                maxInput.value = Math.round(maxValue);
                            }

                            function getValueFromPosition(clientX) {
                                const rect = slider.getBoundingClientRect();
                                const percent = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
                                
                                // Unscale the value to get a more linear distribution
                                const scaledValue = percent * max;
                                return unscaleValue(scaledValue, max);
                            }

                            function handleMouseMove(e) {
                                if (isDraggingMin) {
                                    let newMinValue = getValueFromPosition(e.clientX);
                                    const currentMaxValue = parseFloat(maxInput.value);
                                    newMinValue = Math.min(newMinValue, currentMaxValue);
                                    updateSlider(newMinValue, currentMaxValue);
                                }
                                if (isDraggingMax) {
                                    let newMaxValue = getValueFromPosition(e.clientX);
                                    const currentMinValue = parseFloat(minInput.value);
                                    newMaxValue = Math.max(newMaxValue, currentMinValue);
                                    updateSlider(currentMinValue, newMaxValue);
                                }
                            }

                            function handleTouchMove(e) {
                                e.preventDefault(); // Prevent scrolling while dragging
                                const touch = e.touches[0];
                                handleMouseMove({ clientX: touch.clientX });
                            }

                            function handleMouseUp() {
                                if (isDraggingMin || isDraggingMax) {
                                    // Only trigger filter when mouse/touch is released
                                    if (window.applyFiltersToResults) {
                                        applyFiltersToResults();
                                    }
                                    
                                    // Trigger search input to refresh results
                                    const searchInput = document.getElementById('searchInput');
                                    if (searchInput) {
                                        searchInput.dispatchEvent(new Event('input'));
                                    }
                                }
                                isDraggingMin = false;
                                isDraggingMax = false;
                                document.removeEventListener('mousemove', handleMouseMove);
                                document.removeEventListener('mouseup', handleMouseUp);
                            }

                            function handleTouchEnd() {
                                handleMouseUp();
                                document.removeEventListener('touchmove', handleTouchMove);
                                document.removeEventListener('touchend', handleTouchEnd);
                            }

                            // Mouse events
                            minHandle.addEventListener('mousedown', (e) => {
                                e.preventDefault();
                                isDraggingMin = true;
                                document.addEventListener('mousemove', handleMouseMove);
                                document.addEventListener('mouseup', handleMouseUp);
                            });

                            maxHandle.addEventListener('mousedown', (e) => {
                                e.preventDefault();
                                isDraggingMax = true;
                                document.addEventListener('mousemove', handleMouseMove);
                                document.addEventListener('mouseup', handleMouseUp);
                            });

                            // Touch events
                            minHandle.addEventListener('touchstart', (e) => {
                                e.preventDefault();
                                isDraggingMin = true;
                                document.addEventListener('touchmove', handleTouchMove, { passive: false });
                                document.addEventListener('touchend', handleTouchEnd);
                            });

                            maxHandle.addEventListener('touchstart', (e) => {
                                e.preventDefault();
                                isDraggingMax = true;
                                document.addEventListener('touchmove', handleTouchMove, { passive: false });
                                document.addEventListener('touchend', handleTouchEnd);
                            });

                            // Initial setup
                            updateSlider(0, roundedMaxReviewCount);

                            // Add reset method to window scope
                            window.resetReviewCountSlider = () => {
                                // Reset to full range of review counts
                                updateSlider(0, roundedMaxReviewCount);

                                // Trigger filter application
                                if (window.applyFiltersToResults) {
                                    applyFiltersToResults();
                                }
                                
                                // Trigger search input to refresh results
                                const searchInput = document.getElementById('searchInput');
                                if (searchInput) {
                                    searchInput.dispatchEvent(new Event('input'));
                                }
                            };
                        }

                        // Run after page load
                        document.addEventListener('DOMContentLoaded', createRatingRangeSlider);
                        document.addEventListener('DOMContentLoaded', () => {
                            // Wait for allBlends to be populated
                            const checkAllBlends = setInterval(() => {
                                if (window.allBlends && window.allBlends.length > 0) {
                                    clearInterval(checkAllBlends);
                                    createReviewCountRangeSlider();
                                }
                            }, 100);
                        });
                    </script>

                    <div class="my-4"></div>

                    <script>
                        // Mobile sidebar toggle functionality
                        function initMobileSidebar() {
                            const mobileFilterToggle = document.getElementById('mobileFilterToggle');
                            const mobileSidebar = document.getElementById('mobileSidebar');

                            if (mobileFilterToggle && mobileSidebar) {
                                mobileFilterToggle.addEventListener('click', () => {
                                    mobileSidebar.classList.toggle('hidden');
                                    // Update button text and header shadow
                                    const isVisible = !mobileSidebar.classList.contains('hidden');
                                    const mobileHeader = document.getElementById('mobileHeader');
                                    if (mobileHeader) {
                                        if (isVisible) {
                                            mobileHeader.classList.remove('shadow-lg', 'shadow-black/25');
                                            mobileSidebar.classList.add('shadow-lg', 'shadow-black/25', 'pb-4');
                                        } else {
                                            mobileHeader.classList.add('shadow-lg', 'shadow-black/25');
                                            mobileSidebar.classList.remove('shadow-lg', 'shadow-black/25', 'pb-4');
                                        }
                                    }
                                    mobileFilterToggle.innerHTML = isVisible ? 
                                        `<svg class="w-6 h-6 pointer-events-none" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="z-index: -1;">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                                        </svg>
                                        <span class="pointer-events-none">Close Filters</span>` :
                                        `<svg class="w-6 h-6 pointer-events-none" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="z-index: -1;">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4"></path>
                                        </svg>
                                        <span class="pointer-events-none">Filters</span>`;
                                });

                                // Close sidebar when clicking outside on mobile
                                document.addEventListener('click', (event) => {
                                    if (window.innerWidth < 768) { // Only on mobile
                                        const isClickInside = mobileSidebar.contains(event.target) || 
                                                             mobileFilterToggle.contains(event.target);
                                        if (!isClickInside && !mobileSidebar.classList.contains('hidden')) {
                                            mobileSidebar.classList.add('hidden');
                                            mobileFilterToggle.innerHTML = 
                                                `<svg class="w-6 h-6 pointer-events-none" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="z-index: -1;">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4"></path>
                                                </svg>
                                                <span class="pointer-events-none">Filters</span>`;
                                        }
                                    }
                                });
                            }
                        }

                        // Initialize mobile sidebar
                        document.addEventListener('DOMContentLoaded', initMobileSidebar);

                        // Function to collapse a section
                        function collapseSection(container, arrow) {
                            if (container.id === 'filtersContainer') {
                                container.classList.add('md:hidden');
                            } else {
                                container.classList.add('hidden');
                            }
                            arrow.style.transform = 'rotate(0deg)';
                        }

                        // Filters header click handler for desktop
                        document.getElementById('filtersHeader').addEventListener('click', () => {
                            const filtersContainer = document.getElementById('filtersContainer');
                            const filtersArrow = document.getElementById('filtersArrow');
                            const componentsContainer = document.getElementById('componentsCheckboxContainer');
                            const componentsArrow = document.getElementById('componentsArrow');
                            const isExpanded = !filtersContainer.classList.contains('md:hidden');
                            
                            if (isExpanded) {
                                // Collapse filters
                                collapseSection(filtersContainer, filtersArrow);
                            } else {
                                // Collapse components first
                                collapseSection(componentsContainer, componentsArrow);
                                // Expand filters
                                filtersContainer.classList.remove('md:hidden');
                                filtersArrow.style.transform = 'rotate(180deg)';
                            }
                        });

                        // Function to handle components toggle
                        function handleComponentsToggle(isDesktop = false) {
                            const filtersContainer = document.getElementById('filtersContainer');
                            const filtersArrow = document.getElementById('filtersArrow');
                            const componentsContainer = document.getElementById('componentsCheckboxContainer');
                            const arrow = isDesktop ? document.getElementById('componentsArrow') : document.getElementById('mobileComponentsArrow');
                            const isExpanded = componentsContainer.classList.contains('hidden');
                            
                            if (isExpanded) {
                                if (isDesktop) {
                                    // On desktop, collapse filters first
                                    collapseSection(filtersContainer, filtersArrow);
                                }
                                // Expand components
                                componentsContainer.classList.remove('hidden');
                                arrow.style.transform = 'rotate(180deg)';
                            } else {
                                // Collapse components
                                componentsContainer.classList.add('hidden');
                                arrow.style.transform = 'rotate(0deg)';
                            }
                        }

                        // Desktop components header click handler
                        document.getElementById('componentsHeader').addEventListener('click', () => handleComponentsToggle(true));

                        // Mobile components header click handler
                        document.getElementById('mobileComponentsHeader').addEventListener('click', () => handleComponentsToggle(false));
                    </script>

                    <div class="my-4"></div>
                </div>
            </div>

            <!-- Content Area -->
            <div class="content-area flex-grow overflow-hidden">
                <!-- Results Container -->
                <div class="results-container h-full overflow-y-auto p-4" id="searchResults">
                    <div id="searchSummary" class="text-[#8E8074] text-sm mb-4"></div>
                    <div class="text-[#8E8074] px-4 pt-4">
                        <span id="resultsCounter">Loading results...</span>
                    </div>
                    <div id="searchResults" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
                        <!-- Blend results will be dynamically populated here -->
                    </div>
                </div>
            </div>
        </div>


    </div>

    <div id="blendPopup" class="hidden fixed inset-0 bg-black bg-opacity-70 z-50 flex items-center justify-center">
        <div id="popupContent" class="relative bg-[#42332E] rounded-xl w-auto max-w-[90vw] flex flex-col items-center justify-center"></div>
    </div>

    <!-- Name Input Popup -->
    <div id="nameInputPopup" class="hidden fixed inset-0 bg-black bg-opacity-70 z-[1100] flex items-center justify-center p-4">
        <div class="bg-[#362C29] rounded-xl p-6 max-w-md w-full">
            <h3 class="text-xl font-semibold mb-4">Include your name to be credited!</h3>
            <input type="text" id="submitterName" class="w-full px-4 py-2 rounded bg-[#42332E] mb-4" placeholder="">
            <div class="flex justify-end gap-3">
                <button id="cancelPhotoSubmit" class="px-4 py-2 rounded bg-[#42332E] hover:bg-[#312926] transition-colors">Cancel</button>
                <button id="confirmPhotoSubmit" class="px-4 py-2 rounded bg-[#53403A] hover:bg-[#cead59] transition-colors">Submit</button>
            </div>
        </div>
    </div>

    <!-- Loading Animation -->
    <div id="loadingSpinner" class="hidden fixed inset-0 bg-black bg-opacity-70 z-[1200] flex items-center justify-center">
        <div class="bg-[#362C29] rounded-xl p-6">
            <div class="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-[#42332E] mx-auto"></div>
            <p class="text-center mt-4">Uploading photo...</p>
        </div>
    </div>

    <div id="uploadNotification" class="hidden fixed left-1/2 transform -translate-x-1/2 top-[-80px] bg-green-500 text-[#8E8074] px-4 py-2 rounded-lg shadow-lg transition-all duration-300 z-[60] opacity-100"></div>

    <div id="loadingOverlay" class="fixed inset-0 bg-black bg-opacity-70 z-[100] flex flex-col items-center justify-center hidden">
        <div class="w-80 bg-[#2E221F] rounded-2xl shadow-2xl border border-[#49362F] p-8 text-center transform transition-all duration-300 ease-in-out">
            <div class="mb-6 flex justify-center">
                <svg class="animate-spin h-12 w-12 text-[#C89F65]" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-30" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-80" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
            </div>
            <h2 class="text-2xl font-bold mb-4 text-[#D6B680] tracking-wide">Welcome!</h2>
            <div class="w-full bg-[#3C2E29] rounded-full h-3 mb-4 overflow-hidden">
                <div id="loadingProgress" class="bg-gradient-to-r from-[#705235] to-[#C89F65] h-4 rounded-full transition-all duration-500 ease-out" style="width: 0%"></div>
            </div>
            <p id="loadingText" class="text-[#A48B72] text-sm font-medium tracking-wider uppercase">Initializing...</p>
        </div>
    </div>    

    <script type="module">
        // Import popup modules
        import * as popupModule from './blend_html/popup.js';
        import { initDonationPopup } from './assets/js/donation-popup.js';
        import { initInfoPopup } from './assets/js/info-popup.js';
        
        // Make sure popup module is available globally
        window.popupModule = popupModule;

        // Initialize popups after DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            initDonationPopup();
            initInfoPopup();
        });

        // Global variables initialization
        // Initialize infinite scroll state
        window.isLoading = false;
        window.currentIndex = 0;
        window.LOAD_CHUNK_SIZE = 12;
        window.currentSearchResults = [];
        window.allBlends = [];
        window.allBlendResults = [];
        window.totalBlends = 0;
        
        // Constants
        const BLEND_DATA_PATH = '/blend_data/';


        // Get DOM elements
        const searchInput = document.getElementById('searchInput');
        const suggestionsList = document.getElementById('suggestionsList');
        const searchResults = document.getElementById('searchResults') || document.createElement('div');
        const debugOutput = document.getElementById('debugOutput');




        const loadingOverlay = document.getElementById('loadingOverlay');

        // Ensure searchResults is always a valid element
        if (!searchResults.id) {
            searchResults.id = 'searchResults';
            searchResults.className = 'grid grid-cols-3 gap-4 mt-4';
            document.querySelector('.flex-1.px-8.py-8').appendChild(searchResults);
        }

        // Function to update loading progress
        function updateLoadingProgress(progress, text = 'Loading...') {
            loadingProgress.style.width = `${Math.min(100, Math.max(0, progress))}%`;
            loadingText.textContent = text;
        }

        // Function to dynamically load dropdown options from JSON
        /**
         * Dynamically loads dropdown options from JSON files
         * and populates the corresponding dropdown elements.
         * Also loads component checkboxes.
         */
        async function loadDropdownOptions() {
            const dropdownConfigs = [
                { id: 'blenderDropdown', file: '/assets/data/blenders.json', defaultText: 'All Brands' },
                { id: 'blendedByDropdown', file: '/assets/data/blended_by.json', defaultText: 'All Blenders' },
                { id: 'manufacturedByDropdown', file: '/assets/data/manufactured_by.json', defaultText: 'All Manufacturers' },
                { id: 'countryDropdown', file: '/assets/data/countries.json', defaultText: 'All Countries' },
                { id: 'cutTypeDropdown', file: '/assets/data/cut_types.json', defaultText: 'All Cut Types' },
                { id: 'packagingDropdown', file: '/assets/data/packaging_types.json', defaultText: 'All Packaging Types' },
                { id: 'blendTypeDropdown', file: '/assets/data/blend_types.json', defaultText: 'All Blend Types' },
                { id: 'productionDropdown', file: '/assets/data/production_status.json', defaultText: 'All availabilities' }
            ];

            for (const config of dropdownConfigs) {
                const dropdown = document.getElementById(config.id);
                
                // Clear existing options except the default
                while (dropdown.options.length > 1) {
                    dropdown.remove(1);
                }

                try {
                    // console.log(`Loading options for ${config.id} from ${config.file}`);
                    const response = await fetch(config.file);
                    if (!response.ok) {
                        throw new Error(`Failed to load ${config.file}. Status: ${response.status}`);
                    }
                    const options = await response.json();
                    // console.log(`Options for ${config.id}:`, options);

                    // Special handling for packaging dropdown to extract first value
                    const filteredOptions = config.id === 'packagingDropdown' 
                        ? options.map(item => Array.isArray(item) ? item[0] : item).filter(opt => opt.trim() !== '')
                        : options.filter(opt => opt.trim() !== '');

                    // Use a Set to ensure unique options
                    const uniqueOptions = [...new Set(filteredOptions)];

                    // console.log(`Filtered options for ${config.id}:`, uniqueOptions);

                    uniqueOptions.forEach(option => {
                        // Check if option already exists to prevent duplicates
                        const existingOption = Array.from(dropdown.options).find(opt => opt.value === option);
                        if (!existingOption) {
                            const optionElement = document.createElement('option');
                            optionElement.value = option;
                            optionElement.textContent = option;
                            dropdown.appendChild(optionElement);
                        }
                    });

                    // console.log(`Added ${uniqueOptions.length} unique options to ${config.id}`);
                } catch (error) {
                    console.error(`Error loading dropdown options for ${config.id}:`, error);
                }
            }

            // Load Components Checkboxes
            fetch('/assets/data/contents.json')
                .then(response => response.json())
                .then(components => {
                    // console.log('Loading component checkboxes');
                    const container = document.getElementById('componentsCheckboxContainer');
                    
                    // Clear existing checkboxes to prevent duplicates
                    container.innerHTML = '';
                    
                    components.forEach(component => {
                        const checkboxWrapper = document.createElement('label');
                        checkboxWrapper.className = 'custom-checkbox-container';
                        
                        const checkboxDiv = document.createElement('div');
                        checkboxDiv.className = 'custom-checkbox';
                        
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.className = 'component-checkbox';
                        checkbox.id = `component-${component.replace(/\s+/g, '-').toLowerCase()}`;
                        checkbox.value = component;
                        
                        // Add change listener directly when creating checkbox
                        checkbox.addEventListener('change', () => {
                            console.log(`Component checkbox changed: ${component} - checked: ${checkbox.checked}`);
                            performSearch(); // Use the new performSearch function
                        });
                        
                        const checkmark = document.createElement('div');
                        checkmark.className = 'checkmark';
                        
                        const label = document.createElement('span');
                        label.className = 'custom-checkbox-label text-[#8E8074]';
                        label.htmlFor = checkbox.id;
                        label.textContent = component;
                        
                        checkboxDiv.appendChild(checkbox);
                        checkboxDiv.appendChild(checkmark);
                        checkboxWrapper.appendChild(checkboxDiv);
                        checkboxWrapper.appendChild(label);
                        container.appendChild(checkboxWrapper);
                    });
                });
        }

        // Simplified blend loading without caching
        async function fetchAllBlends() {
            try {
                // Fetch blends from JSON
                const response = await fetch('/assets/data/blend_index.json');
                const blendIndex = await response.json();
                
                // Convert the index to an array of blend objects with full property names
                const blends = Object.entries(blendIndex).map(([filename, data]) => {
                    return {
                        filename,
                        name: data.n || '',
                        blender: data.b || '',
                        blendedBy: data.bb || '',
                        manufacturedBy: data.mb || '',
                        blendType: data.t || '',
                        contents: data.c || '',
                        averageRating: data.r || 0,
                        reviewCount: data.rc || 0,
                        cut: data.ct || '',
                        country: data.y || '',
                        packaging: data.p || '',
                        production: data.pr || '',
                        // Explicitly add properties used in display
                        n: data.n || '',
                        b: data.b || '',
                        bb: data.bb || '',
                        mb: data.mb || '',
                        t: data.t || '',
                        c: data.c || '',
                        r: data.r || 0,
                        rc: data.rc || 0,
                        pr: data.pr || ''
                    };
                });

                // Hide initial loading overlay
                const initialLoadingOverlay = document.getElementById('initialLoadingOverlay');
                if (initialLoadingOverlay) {
                    initialLoadingOverlay.classList.add('hidden');
                }

                return blends;
            } catch (error) {
                console.error('Error loading blend index:', error);
                return [];
            }
        }

        // Modify initial search to use direct loading
        async function loadBlendManifest() {
            try {
                const response = await fetch('/assets/data/blend_manifest.json');
                if (!response.ok) {
                    throw new Error(`Failed to load manifest: ${response.status}`);
                }
                const text = await response.text();
                return text.split('\n').filter(line => line.trim().length > 0);
            } catch (error) {
                console.error('Error loading blend manifest:', error);
                return [];
            }
        }

        async function loadBlendIndex() {
            try {
                const response = await fetch('/assets/data/blend_index.json');
                if (!response.ok) {
                    throw new Error(`Failed to load blend index: ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                console.error('Error loading blend index:', error);
                return {};
            }
        }

        async function loadBlendFile(filename) {
            try {
                // Load the full blend data
                const response = await fetch(`/blend_data/${filename}`);
                if (!response.ok) {
                    console.warn(`Failed to load blend file ${filename}:`, response.status);
                    return null;
                }
                const blendData = await response.json();
                const blendKey = Object.keys(blendData)[0];
                const fullData = blendData[blendKey];
                
                // Return full blend data
                return {
                    filename: filename,
                    name: fullData.name || 'Unnamed Blend',
                    blender: fullData.blender || 'Unknown',
                    blendedBy: fullData.blendedBy || '',
                    manufacturedBy: fullData.manufacturedBy || '',
                    blendType: fullData.blendType || 'Unspecified',
                    averageRating: fullData.averageRating || 0,
                    reviewCount: fullData.reviewCount || 0,
                    contents: fullData.contents || '',
                    cut: fullData.cut || '',
                    country: fullData.country || '',
                    packaging: fullData.packaging || '',
                    production: fullData.production || '',
                    searchText: `${filename} ${fullData.name || ''} ${fullData.blender || ''} ${fullData.blendType || ''}`.toLowerCase()
                };
            } catch (error) {
                console.warn(`Error loading blend file ${filename}:`, error);
                return null;
            }
        }

        // Simplified blend loading without caching
        // Function already defined above, removing this duplicate

        // Modify performSearch to use new filtering approach
        function performSearch() {
            if (!blendSearch) return;

            const searchTerm = document.getElementById('searchInput').value;
            
            // Get selected components
            const selectedComponents = Array.from(
                document.querySelectorAll('.component-checkbox:checked')
            ).map(cb => cb.value);

            // Collect filter values
            const filters = {
                blender: document.getElementById('blenderDropdown').value,
                blendedBy: document.getElementById('blendedByDropdown').value,
                manufacturedBy: document.getElementById('manufacturedByDropdown').value,
                country: document.getElementById('countryDropdown').value,
                cutType: document.getElementById('cutTypeDropdown').value,
                packaging: document.getElementById('packagingDropdown').value,
                blendType: document.getElementById('blendTypeDropdown').value,
                availability: document.getElementById('productionDropdown').value
            };

            // Remove empty filters
            Object.keys(filters).forEach(key => {
                if (filters[key] === '' || filters[key] === 'All ' + key.charAt(0).toUpperCase() + key.slice(1) + 's') {
                    delete filters[key];
                }
            });

            // Perform search
            const results = blendSearch.search(searchTerm, selectedComponents, filters);
            
            // Update current search results
            window.currentSearchResults = results;
            
            // Reset scroll state and display new results
            window.currentIndex = 0;
            window.isLoading = false;
            if (window.scrollObserver) {
                const oldTrigger = document.getElementById('loadingTrigger');
                if (oldTrigger) {
                    window.scrollObserver.unobserve(oldTrigger);
                    oldTrigger.remove();
                }
            }
            displayResults(results);
        }

        // Unified sort function
        function performSort() {
            if (!blendSearch) return;

            const sortDropdown = document.getElementById('sortDropdown');
            const sortKey = sortDropdown.value;
            
            let key = 'n';  // Default
            let ascending = true;

            switch(sortKey) {
                case 'averageRating':
                    key = 'r';
                    ascending = false;
                    break;
                case 'ratingLowToHigh':
                    key = 'r';
                    ascending = true;
                    break;
                case 'reviewCount':
                    key = 'rc';
                    ascending = false;
                    break;
                case 'reviewCountLowToHigh':
                    key = 'rc';
                    ascending = true;
                    break;
                case 'blenderAsc':
                    key = 'b';
                    ascending = true;
                    break;
                case 'blenderDesc':
                    key = 'b';
                    ascending = false;
                    break;
                case 'alphaAsc':
                    key = 'n';
                    ascending = true;
                    break;
                case 'alphaDesc':
                    key = 'n';
                    ascending = false;
                    break;
            }

            blendSearch.sort(key, ascending);
            
            // Reset scroll state and display new results
            window.currentIndex = 0;
            window.isLoading = false;
            if (window.scrollObserver) {
                const oldTrigger = document.getElementById('loadingTrigger');
                if (oldTrigger) {
                    window.scrollObserver.unobserve(oldTrigger);
                }
            }
            displayResults(blendSearch.currentResults);
        }

        window.isLoading = false;
        window.currentIndex = 0;
        window.INITIAL_LOAD_SIZE = 48; // Initial page load size
        window.LOAD_CHUNK_SIZE = 24; // Subsequent chunk size

        // Function to display results with infinite scroll
        function displayResults(results, append = false) {
            // Validate searchResults container
            if (!searchResults) {
                console.error('Search results container not found');
                return;
            }

            // More comprehensive result validation
            const validResults = results.filter(blend => {
                if (!blend || typeof blend !== 'object') {
                    console.warn('Invalid blend (not an object):', blend);
                    return false;
                }
                return blend.n || blend.b || blend.t || blend.filename;
            });

            // Initialize or update infinite scroll observer
            if (!window.scrollObserver) {
                const observerOptions = {
                    root: null,
                    rootMargin: '500px',
                    threshold: 0.1
                };

                const loadMoreCallback = (entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting && !window.isLoading) {
                            if (window.currentIndex < validResults.length) {
                                console.log(`Triggering load more at index ${window.currentIndex} of ${validResults.length}`);
                                window.isLoading = true;
                                displayResults(window.currentSearchResults || [], true);
                            }
                        }
                    });
                };

                window.scrollObserver = new IntersectionObserver(loadMoreCallback, observerOptions);
            }

            // Update global current search results only on initial load
            if (!append) {
                window.allBlendResults = validResults;
                window.currentSearchResults = validResults;
            }

            // Clear results if not appending
            if (!append) {
                searchResults.innerHTML = '';
                window.currentIndex = 0;
                window.isLoading = false;
                window.scrollObserverInitialized = false;
                // Update the current search results
                window.currentSearchResults = validResults;
            }

            if (validResults.length === 0 && !append) {
                searchResults.innerHTML = `
                    <div class="col-span-full text-center text-[#8E8074]">
                        <p class="text-xl mb-4">This is uncharted territory!</p>
                        <p class="text-sm text-[#8E8074]">Try adjusting your search or filters</p>
                    </div>
                `;
                return;
            }

            // Calculate the chunk of results to display
            const start = window.currentIndex;
            const chunkSize = window.currentIndex === 0 ? window.INITIAL_LOAD_SIZE : window.LOAD_CHUNK_SIZE;
            const end = Math.min(start + chunkSize, validResults.length);
            const chunkResults = validResults.slice(start, end);
            window.currentIndex = end;
            
            console.log(`Loading chunk: ${start} to ${end} (${chunkResults.length} blends)`);

            // Handle grid container
            let gridContainer;
            if (!append) {
                // Clear and create new grid for fresh results
                searchResults.innerHTML = '';
                gridContainer = document.createElement('div');
                gridContainer.className = 'grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4';
                searchResults.appendChild(gridContainer);
            } else {
                // Get existing grid for appending
                gridContainer = document.querySelector('#searchResults .grid');
                if (!gridContainer) {
                    console.error('Grid container not found for append');
                    return;
                }
            }

            // Set loading state before processing chunks
            if (!append) {
                window.isLoading = true;
            }
            
            // Update results counter
            const resultsCounter = document.getElementById('resultsCounter');
            if (resultsCounter) {
                resultsCounter.textContent = `Displaying ${Math.min(window.currentIndex, validResults.length)} of ${validResults.length} results`;
            }

            // Display the chunk results
            chunkResults.forEach(blend => {
                const rating = blend.r ? 
                    (typeof blend.r === 'number' ? 
                        blend.r.toFixed(1) : 
                        parseFloat(blend.r).toFixed(1)) : 
                    'N/A';

                const ratingClass = blend.rc === 0 ? 
                    'absolute top-0 right-0 text-[#C89F65] text-base font-bold opacity-40' : 
                    'absolute top-0 right-0 text-[#C89F65] text-base font-bold';

                const ratingsClass = blend.rc === 0 ? 
                    'italic opacity-40' : 
                    'italic';

                const formatComponents = (components) => {
                    if (Array.isArray(components)) {
                        return components.join(', ');
                    }
                    if (typeof components === 'string') {
                        return components;
                    }
                    return 'N/A';
                };

                const additionalDetails = [
                    { label: 'Cut Type', value: blend.cut || 'N/A' },
                    { label: 'Country', value: blend.country || 'N/A' },
                    { label: 'Availability', value: blend.production || 'N/A' },
                    { label: 'Packaging', value: blend.packaging || 'N/A' },
                    { label: 'Components', value: formatComponents(blend.contents) }
                ];

                const hoverDetailsHTML = `
                    <div class="hover-details absolute inset-0 bg-[#241e1c] rounded-lg p-4 flex flex-col justify-center opacity-0 group-hover:opacity-100 transition-opacity duration-300 ease-in-out">
                        <div class="detail-row flex justify-between items-center text-xs text-[#8E8074] mt-2 mb-2">
                            <span class="truncate max-w-[45%]">${blend.country || 'N/A'}</span>
                            <span class="truncate max-w-[45%] ${blend.production === 'No longer in production' ? 'opacity-40' : ''}">${blend.production || 'N/A'}</span>
                        </div>
                        <div class="detail-row flex justify-between items-center text-xs text-[#8E8074] mt-2 mb-2">
                            <span class="truncate max-w-[45%]">${blend.cut || 'N/A'}</span>
                            <span class="truncate max-w-[45%]">${blend.packaging || 'N/A'}</span>
                        </div>
                        <div class="detail-row text-center text-xs text-[#8E8074] mt-2">
                            <span>${blend.contents || 'N/A'}</span>
                        </div>
                    </div>
                `;

                const blendCard = document.createElement('div');
                blendCard.className = 'bg-[#241e1c] rounded-lg p-4 shadow-lg hover:shadow-2xl hover:-translate-y-1 hover:-translate-x-1 transition-all duration-300 ease-in-out cursor-pointer group blend-card relative';
                blendCard.setAttribute('data-blend-key', blend.filename);
                blendCard.innerHTML = `
                    <div class="blend-card relative">
                        <div class="${ratingClass}">
                             ${rating}
                        </div>
                        <h3 class="text-lg font-semibold text-[#C89F65] opacity-70 mb-2">${blend.n || blend.filename || 'Unnamed Blend'}</h3>
                        <div class="text-sm text-[#8E8074] mb-2">${blend.b || 'Unknown Brand'}</div>
                        <div class="flex justify-between items-center text-sm text-[#8E8074]">
                            <span>${blend.t || 'Unspecified Type'}</span>
                            <span class="${ratingsClass}">${blend.rc || 0} Ratings</span>
                        </div>
                        ${hoverDetailsHTML}
                    </div>
                `;
                
                blendCard.addEventListener('click', () => window.popupModule.openPopup(blend.filename));
                gridContainer.appendChild(blendCard);
            });

            // Update search summary
            const searchSummary = document.getElementById('searchSummary');
            if (searchSummary) {
                searchSummary.textContent = `Showing ${Math.min(window.currentIndex, validResults.length)} of ${validResults.length} blend${validResults.length !== 1 ? 's' : ''}`;
            } else {
                console.warn('Search summary element not found');
            }

            // Reset loading state after rendering
            window.isLoading = false;
            console.log(`Loaded ${chunkResults.length} blends. Total: ${validResults.length}. Current index: ${window.currentIndex}`);

            // Update or create loading trigger if more results available
            let loadingTrigger = document.getElementById('loadingTrigger');
            if (loadingTrigger) {
                window.scrollObserver.unobserve(loadingTrigger);
                loadingTrigger.remove();
            }
            
            // Only add loading trigger if there are more filtered results to load
            if (window.currentIndex < window.currentSearchResults.length) {
                loadingTrigger = document.createElement('div');
                loadingTrigger.id = 'loadingTrigger';
                loadingTrigger.className = 'h-32'; // Increased height for earlier trigger
                gridContainer.appendChild(loadingTrigger);
                window.scrollObserver.observe(loadingTrigger);
            }
        }

        // Initialize infinite scroll variables
        if (!window.infiniteScrollInitialized) {
            window.isLoading = false;
            window.currentIndex = 0;
            window.LOAD_CHUNK_SIZE = 12;
            window.infiniteScrollInitialized = true;
        }

        // Popup opening function to fetch full details
        window.openBlendPopup = async function(filename) {
            try {
                // Use the renderBlendPopup from popup.js to handle popup rendering
                await renderBlendPopup(filename);
            } catch (error) {
                console.error('Error opening blend popup:', error);
                // Fallback error handling
                const blendPopup = document.getElementById('blendPopup');
                const popupContent = document.getElementById('popupContent');
                
                popupContent.innerHTML = `
                    <div class="text-center text-red-500 p-6">
                        <h2 class="text-2xl mb-4">Error Loading Blend</h2>
                        <p>Unable to load details for the selected blend.</p>
                        <p class="text-sm mt-2">Filename: ${filename}</p>
                        <button onclick="closePopup()" class="mt-4 px-4 py-2 bg-red-600 text-[#8E8074] rounded">Close</button>
                    </div>
                `;
                
                blendPopup.style.display = 'flex';
            }
        };

        // Ensure popup can be closed
        window.closePopup = function() {
            document.getElementById('blendPopup').style.display = 'none';
        };

        // Global event listener for Escape key to close popups
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const blendPopup = document.getElementById('blendPopup');
                
                // Check if popup is visible using multiple methods
                if (blendPopup && 
                    (blendPopup.style.display !== 'none' || 
                     !blendPopup.classList.contains('hidden') || 
                     blendPopup.classList.contains('flex'))) {
                    
                    // Explicitly hide the popup
                    blendPopup.style.display = 'none';
                    blendPopup.classList.remove('flex');
                    blendPopup.classList.add('hidden');
                }
            }
        });

        // Add initializeBlends function before the window.addEventListener('load')
        async function initializeBlends() {
            try {
                const allBlends = await fetchAllBlends();
                
                if (allBlends.length === 0) {
                    console.error('No blends could be loaded');
                    const searchResults = document.getElementById('searchResults');
                    if (searchResults) {
                        searchResults.innerHTML = '<div class="text-red-500 text-center">Unable to load blends. Please try again later.</div>';
                    }
                    return [];
                }
                
                // Setup search functionality with loaded blends
                setupSearchFunctionality(allBlends);
                
                // Display initial results
                displayResults(allBlends);
                
                return allBlends;
            } catch (error) {
                console.error('Error initializing blends:', error);
                return [];
            }
        }

        // Add setupSearchFunctionality function
        function setupSearchFunctionality(allBlends) {
            // Store allBlends globally to be accessible in other functions
            window.allBlends = allBlends;
            window.allBlendResults = allBlends;
            window.currentSearchResults = allBlends;

            // Create a new BlendSearch instance
            window.blendSearch = new BlendSearch(allBlends);

            // Function to apply all filters and sorting
            function applyFiltersToResults() {
                // Start with the full set of blends
                let filteredBlends = [...allBlends];

                // Get current filter values
                const mobileValue = document.getElementById('searchInput')?.value || '';
                const desktopValue = document.getElementById('desktopSearchInput')?.value || '';
                const searchTerm = (mobileValue || desktopValue).toLowerCase();
                const blenderFilter = document.getElementById('blenderDropdown')?.value.toLowerCase();
                const blendedByFilter = document.getElementById('blendedByDropdown')?.value.toLowerCase();
                const manufacturedByFilter = document.getElementById('manufacturedByDropdown')?.value.toLowerCase();
                const countryFilter = document.getElementById('countryDropdown')?.value.toLowerCase();
                const cutTypeFilter = document.getElementById('cutTypeDropdown')?.value.toLowerCase();
                const packagingFilter = document.getElementById('packagingDropdown')?.value.toLowerCase();
                const blendTypeFilter = document.getElementById('blendTypeDropdown')?.value.toLowerCase();
                const productionFilter = document.getElementById('productionDropdown')?.value.toLowerCase();
                const sortOption = document.getElementById('sortDropdown')?.value;

                // Get selected components
                const selectedComponents = Array.from(
                    document.querySelectorAll('.component-checkbox:checked')
                ).map(checkbox => checkbox.value.toLowerCase());

                // Get rating range
                const minRating = parseFloat(document.getElementById('ratingMinInput').value);
                const maxRating = parseFloat(document.getElementById('ratingMaxInput').value);

                // Get rating count range
                const minReviewCount = parseFloat(document.getElementById('reviewCountMinInput').value);
                const maxReviewCount = parseFloat(document.getElementById('reviewCountMaxInput').value);

                // Text search filter
                if (searchTerm) {
                    filteredBlends = filteredBlends.filter(blend => 
                        blend.name.toLowerCase().includes(searchTerm) ||
                        blend.blender.toLowerCase().includes(searchTerm) ||
                        blend.blendType.toLowerCase().includes(searchTerm) ||
                        blend.contents.toLowerCase().includes(searchTerm)
                    );
                }

                // Blender filter
                if (blenderFilter && blenderFilter !== '') {
                    filteredBlends = filteredBlends.filter(blend => 
                        blend.blender.toLowerCase().includes(blenderFilter)
                    );
                }

                // Blended By filter
                if (blendedByFilter && blendedByFilter !== '') {
                    filteredBlends = filteredBlends.filter(blend => 
                        blend.blendedBy.toLowerCase().includes(blendedByFilter)
                    );
                }

                // Manufactured By filter
                if (manufacturedByFilter && manufacturedByFilter !== '') {
                    filteredBlends = filteredBlends.filter(blend => 
                        blend.manufacturedBy.toLowerCase().includes(manufacturedByFilter)
                    );
                }

                // Country filter
                if (countryFilter && countryFilter !== '') {
                    filteredBlends = filteredBlends.filter(blend => 
                        blend.country.toLowerCase().includes(countryFilter)
                    );
                }

                // Cut Type filter
                if (cutTypeFilter && cutTypeFilter !== '') {
                    filteredBlends = filteredBlends.filter(blend => 
                        blend.cut.toLowerCase() === cutTypeFilter
                    );
                }

                // Packaging filter
                if (packagingFilter && packagingFilter !== '') {
                    filteredBlends = filteredBlends.filter(blend => 
                        blend.packaging.toLowerCase().includes(packagingFilter)
                    );
                }

                // Blend Type filter
                if (blendTypeFilter && blendTypeFilter !== '') {
                    filteredBlends = filteredBlends.filter(blend => 
                        blend.blendType.toLowerCase() === blendTypeFilter
                    );
                }

                // Production/Availability filter
                if (productionFilter && productionFilter !== '' && productionFilter !== 'all availabilities') {
                    filteredBlends = filteredBlends.filter(blend => 
                        blend.production.toLowerCase() === productionFilter
                    );
                }

                // Rating range filter
                filteredBlends = filteredBlends.filter(blend => {
                    const blendRating = blend.averageRating || 0;
                    return blendRating >= minRating && blendRating <= maxRating;
                });

                // Review count filter
                filteredBlends = filteredBlends.filter(blend => {
                    const reviewCount = blend.reviewCount || 0;
                    return reviewCount >= minReviewCount && reviewCount <= maxReviewCount;
                });

                // Components filter
                if (selectedComponents.length > 0) {
                    filteredBlends = filteredBlends.filter(blend => 
                        selectedComponents.every(component => 
                            (blend.contents || '').toLowerCase().split(',')
                                .map(c => c.trim().toLowerCase())
                                .includes(component)
                        )
                    );
                }

                // Sorting
                switch(sortOption) {
                    case 'averageRating':
                        filteredBlends.sort((a, b) => (b.averageRating || 0) - (a.averageRating || 0));
                        break;
                    case 'ratingLowToHigh':
                        filteredBlends.sort((a, b) => (a.averageRating || 0) - (b.averageRating || 0));
                        break;
                    case 'reviewCount':
                        filteredBlends.sort((a, b) => (b.reviewCount || 0) - (a.reviewCount || 0));
                        break;
                    case 'reviewCountLowToHigh':
                        filteredBlends.sort((a, b) => (a.reviewCount || 0) - (b.reviewCount || 0));
                        break;
                    case 'blenderAsc':
                        filteredBlends.sort((a, b) => a.blender.localeCompare(b.blender));
                        break;
                    case 'blenderDesc':
                        filteredBlends.sort((a, b) => b.blender.localeCompare(a.blender));
                        break;
                    case 'alphaAsc':
                        filteredBlends.sort((a, b) => a.name.localeCompare(b.name));
                        break;
                    case 'alphaDesc':
                        filteredBlends.sort((a, b) => b.name.localeCompare(a.name));
                        break;
                }

                // Reset scroll state and display new results
                window.currentIndex = 0;
                window.isLoading = false;
                if (window.scrollObserver) {
                    const oldTrigger = document.getElementById('loadingTrigger');
                    if (oldTrigger) {
                        window.scrollObserver.unobserve(oldTrigger);
                    }
                }
                // Clear the search results container
                const searchResults = document.getElementById('searchResults');
                if (searchResults) {
                    searchResults.innerHTML = '';
                }
                displayResults(filteredBlends);
            }

            // Sync search inputs
            const searchInput = document.getElementById('searchInput');
            const desktopSearchInput = document.getElementById('desktopSearchInput');
            
            if (searchInput && desktopSearchInput) {
                searchInput.addEventListener('input', (e) => {
                    desktopSearchInput.value = e.target.value;
                    applyFiltersToResults();
                });

                desktopSearchInput.addEventListener('input', (e) => {
                    searchInput.value = e.target.value;
                    applyFiltersToResults();
                });
            }

            // Add event listeners to all filter dropdowns
            const filterDropdowns = [
                'blenderDropdown', 
                'blendedByDropdown',
                'manufacturedByDropdown',
                'countryDropdown', 
                'cutTypeDropdown', 
                'packagingDropdown', 
                'blendTypeDropdown',
                'productionDropdown',
                'sortDropdown'
            ];

            filterDropdowns.forEach(dropdownId => {
                const dropdown = document.getElementById(dropdownId);
                if (dropdown) {
                    dropdown.addEventListener('change', applyFiltersToResults);
                }
            });

            // Add event listener for component checkboxes
            const componentCheckboxes = document.querySelectorAll('.component-checkbox');
            componentCheckboxes.forEach(checkbox => {
                checkbox.addEventListener('change', applyFiltersToResults);
            });
        }

        // Simplified Blend Search and Filter Class
        class BlendSearch {
            constructor(blends) {
                this.allBlends = blends;
                this.currentResults = blends;
            }

            // Core search method
            search(query, components = [], filters = {}) {
                // Normalize query
                const normalizedQuery = query.toLowerCase().trim();

                // Filter blends based on query and components
                this.currentResults = this.allBlends.filter(blend => {
                    // Text search across multiple fields
                    const matchesQuery = !normalizedQuery || [
                        blend.name, // name
                        blend.blender, // blender
                        blend.blendType, // blend type
                        blend.contents  // contents
                    ].some(field => 
                        field && field.toLowerCase().includes(normalizedQuery)
                    );

                    // Component filtering
                    const blendContents = (blend.contents || '').toLowerCase().split(',').map(c => c.trim());
                    const matchesComponents = components.length === 0 || 
                        components.every(component => 
                            blendContents.includes(component.toLowerCase())
                        );

                    return matchesQuery && matchesComponents;
                });

                return this.currentResults;
            }

            // Sorting method
            sort(key = 'name', ascending = true) {
                const sortMultiplier = ascending ? 1 : -1;
                
                this.currentResults.sort((a, b) => {
                    const valueA = a[key] || '';
                    const valueB = b[key] || '';

                    if (typeof valueA === 'string') {
                        return sortMultiplier * valueA.localeCompare(valueB);
                    }
                    return sortMultiplier * (valueA - valueB);
                });

                return this.currentResults;
            }
        }

        document.addEventListener('DOMContentLoaded', async () => {
            await loadDropdownOptions();
            await initializeBlends();
            
            // Explicitly set global variables
            window.allBlends = allBlends;
            window.allBlendResults = allBlends;
            window.currentSearchResults = allBlends;
            
            // Setup filter event listeners
            const filterDropdowns = [
                'blenderDropdown', 
                'blendedByDropdown',
                'manufacturedByDropdown',
                'countryDropdown', 
                'cutTypeDropdown', 
                'packagingDropdown', 
                'blendTypeDropdown',
                'productionDropdown',
                'sortDropdown'
            ];

            filterDropdowns.forEach(dropdownId => {
                const dropdown = document.getElementById(dropdownId);
                // Remove any existing listeners first
                const newDropdown = dropdown.cloneNode(true);
                dropdown.parentNode.replaceChild(newDropdown, dropdown);
                newDropdown.addEventListener('change', () => {
                    performSearch(); // Use performSearch instead of applyFiltersToResults
                });
            });

            // Setup search and filter functionality
            setupSearchFunctionality(allBlends);
        });

        // Perform full search
        async function performFullSearch(query) {
            console.log('Performing full search for:', query);
            
            // If no query, reset to all blends
            if (!query) {
                updateSearchResults(window.allBlends);
                return;
            }

            // Use the current filtered results if they exist, otherwise use all blends
            const currentResults = window.currentFilteredResults || window.allBlends;

            // Filter the current results based on the query
            const searchResults = currentResults.filter(blend => 
                blend.n.toLowerCase().includes(query) ||
                blend.d.toLowerCase().includes(query) ||
                blend.components.some(component => 
                    component.name.toLowerCase().includes(query)
                )
            );

            // Update search results without changing the current order
            updateSearchResults(searchResults);
        }

        // Update results summary function
        function updateResultsSummary(totalResults, errorCount, searchTerm) {
            // Calculate search duration
            const searchEndTime = performance.now();
            const searchDuration = ((searchEndTime - searchStartTime) / 1000).toFixed(2);
            
            // Get results summary element
            const resultsSummary = document.getElementById('searchSummary');
            
            if (resultsSummary) {
                if (totalResults > 0) {
                    // For initial load or full results, show total number of blends
                    if (!searchTerm) {
                        resultsSummary.textContent = `Found ${totalResults} total blends in ${searchDuration} seconds`;
                    } else {
                        // For search results, show search-specific message
                        resultsSummary.textContent = `Found ${totalResults} results containing "${searchTerm}" in ${searchDuration} seconds`;
                    }
                } else {
                    resultsSummary.textContent = `No results found${searchTerm ? ` for "${searchTerm}"` : ''}`;
                }
            }
        }

        // Modify sorting and filtering to work with pagination
        function updateSearchResults(results, sortOption = '') {
            console.log('Updating search results. Input results:', results.length);
            
            // Set global total blends
            window.totalBlends = results.length;
            
            // Sort results if a sort option is selected
            if (sortOption) {
                results = sortBlends(results, sortOption);
            }

            // Update search results display
            const searchResultsContainer = document.getElementById('searchResults');
            if (searchResultsContainer) {
                searchResultsContainer.innerHTML = ''; // Clear previous results
                
                // Display results or show no results message
                if (results.length === 0) {
                    searchResultsContainer.innerHTML = '<p>No blends found.</p>';
                }
            }

            // Trigger pagination
            if (typeof displayPaginatedResults === 'function') {
                displayPaginatedResults(results);
            }

            return results;
        }

        // Initialize infinite scroll variables
        if (!window.infiniteScrollInitialized) {
            window.isLoading = false;
            window.currentIndex = 0;
            window.LOAD_CHUNK_SIZE = 12;
            window.infiniteScrollInitialized = true;
        }

        // Sorting functions
        function sortBlends(results, sortOption) {
            switch(sortOption) {
                case 'averageRating':
                    console.log('Sorting by Average Rating (High to Low)');
                    return results.sort((a, b) => (b.r || 0) - (a.r || 0));
                case 'ratingLowToHigh':
                    console.log('Sorting by Average Rating (Low to High)');
                    return results.sort((a, b) => (a.r || 0) - (b.r || 0));
                case 'reviewCount':
                    console.log('Sorting by Review Count (High to Low)');
                    return results.sort((a, b) => (b.rc || 0) - (a.rc || 0));
                case 'reviewCountLowToHigh':
                    console.log('Sorting by Review Count (Low to High)');
                    return results.sort((a, b) => (a.rc || 0) - (b.rc || 0));
                case 'blenderAsc':
                    console.log('Sorting by Blender (A to Z)');
                    return results.sort((a, b) => a.b.localeCompare(b.b));
                case 'blenderDesc':
                    console.log('Sorting by Blender (Z to A)');
                    return results.sort((a, b) => b.b.localeCompare(a.b));
                case 'alphaAsc':
                    console.log('Sorting by Name (A to Z)');
                    return results.sort((a, b) => a.n.localeCompare(b.n));
                case 'alphaDesc':
                    console.log('Sorting by Name (Z to A)');
                    return results.sort((a, b) => b.n.localeCompare(a.n));
            }
        }

        // Add event listener to sort dropdown
        document.getElementById('sortDropdown').addEventListener('change', (event) => {
            const sortOption = event.target.value;
            const currentSearchTerm = searchInput.value;
            
            // Simply apply filters and sorting to current results
            performSort();
        });

        // Event Listeners
        searchInput.addEventListener('keydown', async (e) => {
            if (e.key === 'Enter') {
                const query = e.target.value.trim();
                await performFullSearch(query);
            }
        });

        // Close popup when clicking outside
        document.getElementById('blendPopup').addEventListener('click', function(event) {
            if (event.target === this) {
                this.classList.remove('flex');
                this.classList.add('hidden');
            }
        });

        // Initialize donation popup
        // Popup initialization moved to DOMContentLoaded event above

        // Reset Filters Functionality
        function resetAllFilters() {
            // Reset sort dropdown
            const sortDropdown = document.getElementById('sortDropdown');
            if (sortDropdown) {
                sortDropdown.value = '';
            }

            // Reset brand dropdown
            const blenderDropdown = document.getElementById('blenderDropdown');
            if (blenderDropdown) {
                blenderDropdown.value = '';
            }

            // Reset blended by dropdown
            const blendedByDropdown = document.getElementById('blendedByDropdown');
            if (blendedByDropdown) {
                blendedByDropdown.value = '';
            }

            // Reset manufactured by dropdown
            const manufacturedByDropdown = document.getElementById('manufacturedByDropdown');
            if (manufacturedByDropdown) {
                manufacturedByDropdown.value = '';
            }

            // Reset search input
            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                searchInput.value = '';
            }

            // Reset rating slider
            if (typeof resetRatingSlider === 'function') {
                resetRatingSlider();
            }

            // Reset review count slider
            if (typeof resetReviewCountSlider === 'function') {
                resetReviewCountSlider();
            }

            // Uncheck all component checkboxes
            const componentCheckboxes = document.querySelectorAll('#componentsCheckboxContainer input[type="checkbox"]');
            componentCheckboxes.forEach(checkbox => {
                checkbox.checked = false;
            });

            // Reset country dropdown
            const countryDropdown = document.getElementById('countryDropdown');
            if (countryDropdown) {
                countryDropdown.selectedIndex = 0;
            }

            // Reset cut type dropdown
            const cutTypeDropdown = document.getElementById('cutTypeDropdown');
            if (cutTypeDropdown) {
                cutTypeDropdown.selectedIndex = 0;
            }

            // Reset packaging dropdown
            const packagingDropdown = document.getElementById('packagingDropdown');
            if (packagingDropdown) {
                packagingDropdown.selectedIndex = 0;
            }

            // Reset blend type dropdown
            const blendTypeDropdown = document.getElementById('blendTypeDropdown');
            if (blendTypeDropdown) {
                blendTypeDropdown.selectedIndex = 0;
            }

            // Reset production dropdown
            const productionDropdown = document.getElementById('productionDropdown');
            if (productionDropdown) {
                productionDropdown.selectedIndex = 0;
            }

            // Trigger search to reset results
            if (typeof performSearch === 'function') {
                performSearch();
            } else if (window.allBlends) {
                // Fallback to displaying all blends if performSearch is not available
                window.currentSearchResults = window.allBlends;
                displayPaginatedResults(window.allBlends);
            }
        }

        // Add event listener to reset filters button
        const resetFiltersBtn = document.getElementById('resetFiltersBtn');
        if (resetFiltersBtn) {
            resetFiltersBtn.addEventListener('click', resetAllFilters);
        }

        // Modify existing slider creation functions to add reset method
        function createRatingRangeSlider() {
            // Existing slider creation code...

            // Add reset method
            window.resetRatingSlider = () => {
                const ratingSlider = document.getElementById('ratingSlider');
                const ratingTrack = document.getElementById('ratingTrack');
                const ratingThumb = document.getElementById('ratingThumb');
                const ratingMin = document.getElementById('ratingMin');
                const ratingMax = document.getElementById('ratingMax');

                if (ratingSlider && ratingTrack && ratingThumb && ratingMin && ratingMax) {
                    // Reset to full range
                    ratingMin.textContent = '0';
                    ratingMax.textContent = '5';
                    ratingTrack.style.width = '100%';
                    ratingThumb.style.left = '100%';
                }
            };
        }

        function createReviewCountRangeSlider() {
            // Existing slider creation code...

            // Add reset method
            window.resetReviewCountSlider = () => {
                const reviewSlider = document.getElementById('reviewCountSlider');
                const reviewTrack = document.getElementById('reviewCountTrack');
                const reviewThumb = document.getElementById('reviewCountThumb');
                const reviewMin = document.getElementById('reviewCountMin');
                const reviewMax = document.getElementById('reviewCountMax');

                if (reviewSlider && reviewTrack && reviewThumb && reviewMin && reviewMax) {
                    // Reset to full range
                    reviewMin.textContent = '0';
                    reviewMax.textContent = window.maxReviewCount || '1000';
                    reviewTrack.style.width = '100%';
                    reviewThumb.style.left = '100%';
                }
            };
        }
    </script>
</body>
</html>
