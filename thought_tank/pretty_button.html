    <div style="
position: fixed; 
top: 0; 
left: 0; 
width: 100%; 
height: 100%; 
background-color: rgba(31, 26, 24, 1); /* Deep tobacco background */
display: flex; 
justify-content: center; 
align-items: center; 
z-index: 1000;
">
<canvas id="particleCanvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1;"></canvas>
<button onclick="window.location.href='index.html'" style="
    position: relative;
    z-index: 2;
    padding: 15px 30px;
    font-size: 18px;
    background-color: #25211d;  /* Slightly lighter than background */
    color: #4b4035;  /* Soft leather text color */
    border: 2px solid #3d3123;  /* Muted border color */
    border-radius: 10px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(90, 79, 64, 0.3);  /* Highlight shadow */
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    font-weight: 600;
    outline: none;
" onmouseover="this.style.backgroundColor='rgba(200, 159, 101, 0.5)'; this.style.color='#27201E'; this.style.transform='scale(1.05)'" onmouseout="this.style.backgroundColor='#25211d'; this.style.color='#4b4035'; this.style.transform='scale(1)'">
    UNLOCK TOBACCO KNOWLEDGE
</button>
</div>

<script>
  const canvas = document.getElementById('particleCanvas');
  const ctx = canvas.getContext('2d');
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  let particlesArray = [];
  const numberOfParticles = 5; // Reduced for better performance

  // Button position (approximate, adjust as needed)
  const button = document.querySelector('button'); 
  let buttonX = window.innerWidth / 2;
  let buttonY = window.innerHeight / 2;
  let buttonRadius = 50; // Approximate button radius

  // Global state for particle interactions
  let isHovering = false;
  let isClicking = false;
  let globalSpeedMultiplier = 1;
  let targetSpeedMultiplier = 1;
  const EASING_FACTOR = 0.03; // Smoothing factor for speed transitions

  // Easing functions
  function easeInOutQuad(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  }

  class Particle {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      this.size = Math.random() * 3 + 1;
      this.speedX = 0;
      this.speedY = 0;
      this.baseSpeedX = 0;
      this.baseSpeedY = 0;
      this.opacity = 0; // Start fully transparent
      this.fadeIn = true;
      this.targetReached = false;
      this.clickTargetX = null;
      this.clickTargetY = null;
    }
    
    update() {
      // Smooth speed multiplier transition
      globalSpeedMultiplier += (targetSpeedMultiplier - globalSpeedMultiplier) * EASING_FACTOR;

      // Handle fade in effect
      if (this.fadeIn) {
        this.opacity += 0.05;
        if (this.opacity >= 1) {
          this.opacity = 1;
          this.fadeIn = false;
        }
      }

      // Calculate direction to closest point on button edge
      const dx = buttonX - this.x;
      const dy = buttonY - this.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      // Calculate target point on button edge
      const angle = Math.atan2(dy, dx);
      const targetX = buttonX - Math.cos(angle) * buttonRadius;
      const targetY = buttonY - Math.sin(angle) * buttonRadius;
      
      // Modify speed based on interaction state
      let speedFactor = 3;
      if (isHovering) {
        targetSpeedMultiplier = 0.2; // Significantly slow down
      } else if (isClicking) {
        targetSpeedMultiplier = 2; // Speed up towards button
        this.targetReached = distance < buttonRadius;
        // Move towards click target
        const tdx = this.clickTargetX - this.x;
        const tdy = this.clickTargetY - this.y;
        const targetDistance = Math.sqrt(tdx * tdx + tdy * tdy);
        const targetSpeedX = (tdx / targetDistance) * speedFactor;
        const targetSpeedY = (tdy / targetDistance) * speedFactor;
        this.baseSpeedX = targetSpeedX;
        this.baseSpeedY = targetSpeedY;
      } else {
        targetSpeedMultiplier = 1; // Normal speed
      }

      // Smooth movement towards target
      const tdx = targetX - this.x;
      const tdy = targetY - this.y;
      const targetDistance = Math.sqrt(tdx * tdx + tdy * tdy);
      
      // Interpolate between current and target speed
      const targetSpeedX = (tdx / targetDistance) * speedFactor;
      const targetSpeedY = (tdy / targetDistance) * speedFactor;

      // Apply easing to speed changes
      this.baseSpeedX += (targetSpeedX - this.baseSpeedX) * EASING_FACTOR;
      this.baseSpeedY += (targetSpeedY - this.baseSpeedY) * EASING_FACTOR;

      // Apply speed multiplier
      this.speedX = this.baseSpeedX * globalSpeedMultiplier;
      this.speedY = this.baseSpeedY * globalSpeedMultiplier;

      this.x += this.speedX;
      this.y += this.speedY;

      // Check if particle should be removed
      if (distance < buttonRadius || 
          this.x < 0 || 
          this.x > canvas.width || 
          this.y < 0 || 
          this.y > canvas.height) {
        return true; // Mark for removal
      }
      return false; // Keep particle
    }
    
    draw() {
      ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
      ctx.closePath();
      ctx.fill();
    }
  }

  // Initialize particles
  function init() {
    particlesArray = [];
    for (let i = 0; i < numberOfParticles; i++) {
      let x = Math.random() * canvas.width;
      let y = Math.random() * canvas.height;
      particlesArray.push(new Particle(x, y));
    }
  }

  // Random particle creation interval
  function createParticle() {
    if (!isClicking) {
      let x = Math.random() * canvas.width;
      let y = Math.random() * canvas.height;
      
      // Random position on the edges of the canvas
      let side = Math.floor(Math.random() * 4);
      if (side === 0) { // Top
        x = Math.random() * canvas.width;
        y = 0;
      } else if (side === 1) { // Right
        x = canvas.width;
        y = Math.random() * canvas.height;
      } else if (side === 2) { // Bottom
        x = Math.random() * canvas.width;
        y = canvas.height;
      } else { // Left
        x = 0;
        y = Math.random() * canvas.height;
      }
      
      particlesArray.push(new Particle(x, y));
    }
  }
  const particleCreationInterval = setInterval(createParticle, 100); // Slower particle creation

  // Hover and click event listeners
  button.addEventListener('mouseenter', () => {
    isHovering = true;
    isClicking = false;
  });

  button.addEventListener('mouseleave', () => {
    isHovering = false;
  });

  button.addEventListener('click', (e) => {
    e.preventDefault(); // Prevent immediate navigation
    isClicking = true;
    isHovering = false;

    // Stop creating new particles
    clearInterval(particleCreationInterval);

    // Track convergence state
    let convergenceStartTime = null;
    const MIN_CONVERGENCE_TIME = 5000; // 5 seconds minimum
    const CONVERGENCE_RADIUS = 150; // Even larger convergence radius
    const SPEED_THRESHOLD = 0.01; // Extremely low speed threshold

    // Modify particle behavior for clicking
    particlesArray.forEach(particle => {
      particle.clickTargetX = buttonX;
      particle.clickTargetY = buttonY;
    });

    // Redirect only when all particles have reached the center
    function checkParticleConvergence() {
      // More detailed particle state tracking
      const particleStates = particlesArray.map(particle => {
        const distanceToCenter = Math.sqrt(
          Math.pow(particle.x - particle.clickTargetX, 2) + 
          Math.pow(particle.y - particle.clickTargetY, 2)
        );
        const currentSpeed = Math.sqrt(
          Math.pow(particle.speedX, 2) + 
          Math.pow(particle.speedY, 2)
        );
        const isConverged = distanceToCenter < CONVERGENCE_RADIUS && currentSpeed < SPEED_THRESHOLD;
        
        // Extremely verbose logging
        console.log(`Particle: 
          Distance: ${distanceToCenter.toFixed(2)}, 
          Speed: ${currentSpeed.toFixed(4)}, 
          Converged: ${isConverged}`);
        
        return {
          distanceToCenter,
          currentSpeed,
          isConverged
        };
      });

      // Check if all particles are converged
      const allParticlesConverged = particleStates.every(state => state.isConverged);

      console.log(`All Particles Converged: ${allParticlesConverged}`);

      // First time converging, set start time
      if (allParticlesConverged && convergenceStartTime === null) {
        convergenceStartTime = performance.now();
        console.log('First convergence detected');
      }

      // If still converged, check time
      if (allParticlesConverged && convergenceStartTime !== null) {
        const currentTime = performance.now();
        const elapsedTime = currentTime - convergenceStartTime;

        console.log(`Convergence time: ${elapsedTime}ms`);

        // Redirect after sustained convergence
        if (elapsedTime >= MIN_CONVERGENCE_TIME) {
          console.log('Redirecting...');
          window.location.href = button.getAttribute('onclick').match(/'([^']*)'/)[1];
          return;
        }
      }

      // If not all converged, reset start time
      if (!allParticlesConverged) {
        if (convergenceStartTime !== null) {
          console.log('Convergence broken');
        }
        convergenceStartTime = null;
      }

      // Continue checking
      requestAnimationFrame(checkParticleConvergence);
    }

    // Start checking for particle convergence
    checkParticleConvergence();
  });

  window.addEventListener('resize', function() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    buttonX = canvas.width/2;
    buttonY = canvas.height/2;
    init();
  });

  // Animation loop
  function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // Remove particles marked for deletion
    particlesArray = particlesArray.filter(particle => {
      const shouldRemove = particle.update();
      if (!shouldRemove) {
        particle.draw();
      }
      return !shouldRemove;
    });
    requestAnimationFrame(animate);
  }
  
  init();
  animate();
</script>